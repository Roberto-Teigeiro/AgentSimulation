# -*- coding: utf-8 -*-
"""Evidence2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1GUlwSOPWUdsawIgue6_50OjkzifWUy5o

# Evidence 2

## 0. Installing libraries
"""

!pip install agentpy pathfinding owlready2

import agentpy as ap
import pathfinding as pf        #use pathfinding algorithms for the agent's plan
import matplotlib.pyplot as plt
from owlready2 import *
import itertools
import random
import IPython
import math

"""## 1. Defining Ontology"""

# THIS CELL MUST NOT BE EXECUTED TWICE
# If we need to execute this cell again you can do it deleting the ontology as follows:
#onto.destroy(update_relation = True, update_is_a = True)

#Ontology name and path
onto = get_ontology("file:///content/coin_onto.owl")

# Opening the ontology
with onto:
    # Define core classes
    class Entity(Thing):
        """Superclass for all entities."""
        pass

    class Drone(Entity):
        """Represents the surveillance drone."""
        pass

    class Camera(Entity):
        """Represents a fixed surveillance camera."""
        pass

    class Robber(Entity):
        """Represents a potentially suspicious individual."""
        pass

    class SecurityPersonnel(Entity):
        """Represents a security team member."""
        pass

    class Place(Thing):
        """Represents a specific area or position."""
        pass

    # Define relationships (Object Properties)
    class is_in_place(ObjectProperty):
        """Links an entity to a position (Place)."""
        domain = [Entity]
        range = [Place]

    class at_position(DataProperty,FunctionalProperty):
        """ Specifies the position of a Place """
        domain = [Place]
        range = [str]
        pass

    class detects_suspicion(ObjectProperty):
        """Links a camera or drone to a suspicious entity."""
        domain = [Camera, Drone]
        range = [Robber]

    class alerts(ObjectProperty):
        """Links a camera to a drone or security personnel."""
        domain = [Camera]
        range = [Drone, SecurityPersonnel]

    class patrolled_by(ObjectProperty):
        """Links a place to a drone patrolling it."""
        domain = [Place]
        range = [Drone]

    class status(DataProperty, FunctionalProperty):
        """Indicates the status of an entity."""
        domain = [Entity]
        range = [str]

# Save the ontology
onto.save(file="drone_security_ontology.owl")

# Confirmation
"Ontology defined and saved as 'drone_security_ontology.owl'."

"""## 2. Define agents classes and behaviour"""

class DroneAgent(ap.Agent):
    """Represents a surveillance drone with BDI architecture, focusing on a single robber."""

    def setup(self):
        """Initialize the drone's attributes."""
        self.beliefs = None  # Holds the current belief (if any)
        self.intention = None  # Current goal
        self.plan_steps = []  # Steps to achieve the current intention
        self.intention_succeeded = True  # Whether the current intention has been achieved
        self.patrol_mode = False  # Whether the drone is in patrol mode

    # Perseption phase of BDI cycle
    def see(self, environment):
        """Perception: Detects the robber within range."""
        detection_range = 10  # Example detection range
        detected_robber = next( # next() function ensures that only one robber is returned
            (entity for entity in environment.neighbors(self, distance=detection_range)
             if isinstance(entity, Robber)),
            None  # Default to None if no robber is detected
        )
        return detected_robber

    # Belief Revision Phase of BDI cycle
    def brf(self, detected_robber):
        """
        Belief Revision Function: Updates the belief system based on perceptions.
        """
        # Destroy the previous belief to avoid outdated information
        self.destroy_previous_beliefs()

        # If a robber is detected, update the belief system
        if detected_robber:
            current_position = self.model.grid.positions[detected_robber]
            detected_robber.is_in_place = [Place(at_position=str(current_position))]
            self.beliefs = detected_robber

    # Desire Phase of BDI cycle
    def options(self):
        """
        Generates the current goal (Desire) based on the belief system.
        If a robber is believed to exist, the goal is to inspect its location.
        """
        if self.beliefs: # if the drone believes in the existence of a robber:
            robber_position = eval(self.beliefs.is_in_place[0].at_position)
            current_position = self.model.grid.positions[self]
            distance = math.sqrt(
                (robber_position[0] - current_position[0]) ** 2
                + (robber_position[1] - current_position[1]) ** 2
            )
            return {'inspect_robber': distance}  # Single goal to inspect the robber

        return {}  # No goals if no robber is detected

    # Goal Selection
    def filter(self):
        """
        Selects the most desirable goal (closest or only goal).
        """
        # Since there is only one possible goal (inspect_robber), it is directly selected.
        if self.desires:
            return 'inspect_robber'  # The only goal available
        return None

    def plan(self):
        """
        Creates a plan (sequence of movements) to achieve the current intention.
        """
        if not self.intention:
            return [(0, 0)]  # No intention, stay in place

        current_position = self.model.grid.positions[self]
        target_position = eval(self.beliefs.is_in_place[0].at_position)

        dx = target_position[0] - current_position[0]
        dy = target_position[1] - current_position[1]

        steps_x = [(1 if dx > 0 else -1, 0)] * abs(dx)
        steps_y = [(0, 1 if dy > 0 else -1)] * abs(dy)

        return steps_x + steps_y

    def execute(self):
        """
        Executes the current plan by taking one step at a time.
        """
        if self.plan_steps:
            self.model.grid.move_by(self, self.plan_steps.pop(0))
        else:
            # Plan completed, reset intention
            self.intention_succeeded = True

    def takeoff(self):
        """Simulates the drone taking off from the landing station."""
        self.patrol_mode = True
        print("Drone is taking off and starting patrol.")

    def land(self):
        """Simulates the drone landing at the station."""
        self.patrol_mode = False
        print("Drone has landed safely at the station.")

    def step(self):
        """The main BDI cycle: perception, belief revision, and action."""
        if not self.patrol_mode:
            self.takeoff()

        detected_robber = self.see(self.model.grid)
        self.brf(detected_robber)

        if self.intention_succeeded:
            self.desires = self.options()
            self.intention = self.filter()
            self.plan_steps = self.plan()
            self.intention_succeeded = False

        self.execute()

        # Land at the end of patrol if no more steps or desires
        if not self.plan_steps and self.patrol_mode and not self.desires:
            self.land()

class Robber(ap.Agent):
    """Represents a suspicious entity (robber) in the environment."""

    def setup(self):
        """Initialize the robber's attributes."""
        # No need for separate suspicious behavior
        pass

    def move_randomly(self):
        """Moves the robber randomly within the grid."""
        directions = [(1, 0), (-1, 0), (0, 1), (0, -1), (0, 0)]  # Including staying in place
        step = random.choice(directions)
        self.model.grid.move_by(self, step)

    def step(self):
        """Defines the robber's behavior per simulation step."""
        self.move_randomly()

class CameraAgent(ap.Agent):
    """Represents a stationary surveillance camera."""

    def setup(self):
        """Initialize the camera's attributes."""
        self.detection_range = 20  # Larger range than the drone
        self.alerts_sent = 0  # Tracks the number of alerts sent

    def detect_robber(self):
        """Detects the robber within the camera's perception range."""
        # use neighbors() to find all agents within the specified range
        detected_robber = next(
            (entity for entity in self.model.grid.neighbors(self, distance=self.detection_range)
             if isinstance(entity, RobberAgent)),
            None  # Default to None if no robber is detected
        )
        return detected_robber

    def send_alert(self, robber):
        """Sends an alert to the drone with the robber's location."""
        robber_position = self.model.grid.positions[robber]
        alert = {'location': robber_position, 'source': self}
        self.model.alerts.append(alert)  # Add the alert to the model's alert system
        self.alerts_sent += 1
        print(f"Camera at {self.model.grid.positions[self]} sent an alert: Robber detected at {robber_position}")

    def step(self):
        """Defines the camera's behavior per simulation step."""
        detected_robber = self.detect_robber()
        if detected_robber:
            self.send_alert(detected_robber)

class SecurityPersonnelAgent(ap.Agent):
    """Represents security personnel responsible for simulated control of the drone."""

    def setup(self):
        """Initialize the agent's attributes."""
        self.in_communication = False  # Whether communication with the drone is active
        self.alert_handled = False  # Tracks whether the current alert has been addressed

    def respond_to_drone_signal(self, drone, robber_position):
        """
        Simulates taking control of the drone by communicating with it.

        Args:
            drone (DroneAgent): The drone requesting assistance.
            robber_position (tuple): The location of the detected robber.
        """
        print(f"Security personnel are communicating with the drone at {robber_position}.")
        self.in_communication = True
        self.confirm_robber(drone, robber_position)

    def confirm_robber(self, drone, robber_position):
        """
        Confirms the presence of the robber and issues a general alarm.

        Args:
            drone (DroneAgent): The drone currently under simulated control.
            robber_position (tuple): The location of the detected robber.
        """
        print(f"Robber confirmed at {robber_position}. Issuing a general alarm.")
        self.simulate_general_alarm(drone)

    def simulate_general_alarm(self, drone):
        """Simulates issuing a general alarm."""
        print("General alarm issued. Security personnel have resolved the alert.")
        self.in_communication = False
        self.alert_handled = True
        drone.receive_command("alert_resolved")  # Simulated command to drone

    def step(self):
        """
        Defines the agent's behavior per simulation step.
        Reacts only if an alert is present and the drone signals for assistance.
        """
        if not self.in_communication and not self.alert_handled:
            # Check if the drone has sent a signal for help
            for alert in self.model.alerts:
                if alert['type'] == 'drone_signal':
                    self.respond_to_drone_signal(alert['drone'], alert['location'])
                    self.model.alerts.remove(alert)  # Remove the alert after handling

"""## Additional functions

Destroy Beliefs
"""

def destroy_previous_beliefs(self):
    """Clears outdated beliefs and their associated ontology entities."""
    for belief in self.beliefs:
        destroy_entity(belief.is_in_place[0])  # Destroy associated Place
        destroy_entity(belief)  # Destroy the belief itself (e.g., RobberAgent)
    self.beliefs.clear()  # Reset beliefs list

"""Move the agents thanks to a move_by function."""

def move_by(agent, step):
    """
    Moves the agent by the specified step on the grid.

    Args:
        agent (ap.Agent): The agent to move.
        step (tuple): The step to move, e.g., (1, 0) for right or (0, -1) for down.
    """
    current_position = agent.model.grid.positions[agent]
    new_position = (current_position[0] + step[0], current_position[1] + step[1])

    # Ensure the new position is within grid boundaries
    if agent.model.grid.is_within_bounds(new_position):
        agent.model.grid.move_to(agent, new_position)

"""## Simulation"""

# Drone-Robber World Model
class DroneWorldModel(ap.Model):

    def setup(self):
        """Setup the agents and environment."""
        # Create agents
        self.drones = ap.AgentList(self, self.p.droneAgents, DroneAgent)
        self.cameras = ap.AgentList(self, self.p.cameraAgents, CameraAgent)
        self.robber = ap.AgentList(self, 1, Robber)
        self.security = ap.AgentList(self, 1, SecurityPersonnelAgent)

        # Create the grid
        self.grid = ap.Grid(self, self.p.worldSize, track_empty=True)

        # Add agents to the grid
        self.grid.add_agents(self.drones, random=True, empty=True)
        self.grid.add_agents(self.cameras, random=True, empty=True)
        self.grid.add_agents(self.robber, random=True, empty=True)

        # Initialize alert system
        self.alerts = []

    def step(self):
        """Run one step of the simulation."""
        # Perform agent actions
        self.drones.step()
        self.cameras.step()
        self.robber.step()
        self.security.step()

    def update(self):
        """Custom update logic can go here."""
        pass

    def end(self):
        """End the simulation."""
        print("Simulation finished!")

# Visualization function
def animation_plot(model, ax):
    """Visualizes the grid and agents."""
    agent_grid = model.grid.attr_grid('agent_type')
    ap.gridplot(agent_grid, cmap='tab10', ax=ax)
    ax.set_title(f"Drone-Robber Simulation \n Time-step: {model.t}")

# Parameters
parameters = {
    "droneAgents": 1,        # Number of drones
    "cameraAgents": 4,       # Number of cameras
    "worldSize": (30, 30),   # Grid size
    "steps": 10,            # Maximum steps
    "seed": 42               # Random seed
}

# Create figure
fig, ax = plt.subplots()

# Initialize and run the simulation
model = DroneWorldModel(parameters)

animation = ap.animate(model, fig, ax, animation_plot)

# Display animation
IPython.display.HTML(animation.to_jshtml())
